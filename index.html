<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network Protocol Learning Tool - Computer Science Project</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(to right, #4A00E0, #8E2DE2);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        .header .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
        }
        
        .edu-badge {
            display: inline-block;
            background: #00C853;
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
            margin-top: 10px;
        }
        
        .content {
            display: flex;
            flex-wrap: wrap;
            padding: 30px;
            gap: 30px;
        }
        
        .explanation {
            flex: 1;
            min-width: 300px;
            background: #f8f9fa;
            padding: 25px;
            border-radius: 10px;
            border-left: 5px solid #4A00E0;
        }
        
        .explanation h2 {
            color: #4A00E0;
            margin-bottom: 15px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 10px;
        }
        
        .explanation ul {
            padding-left: 20px;
            margin: 15px 0;
        }
        
        .explanation li {
            margin-bottom: 10px;
            line-height: 1.5;
        }
        
        .demo-area {
            flex: 2;
            min-width: 300px;
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .demo-tabs {
            display: flex;
            background: #f1f3f4;
            border-bottom: 1px solid #ddd;
        }
        
        .tab {
            padding: 15px 25px;
            cursor: pointer;
            border-right: 1px solid #ddd;
            font-weight: 500;
            transition: all 0.3s;
        }
        
        .tab.active {
            background: white;
            border-bottom: 3px solid #4A00E0;
            color: #4A00E0;
        }
        
        .tab-content {
            flex: 1;
            display: none;
            padding: 0;
        }
        
        .tab-content.active {
            display: flex;
            flex-direction: column;
        }
        
        .demo-frame {
            flex: 1;
            width: 100%;
            border: none;
            background: white;
        }
        
        .controls {
            padding: 20px;
            background: #f8f9fa;
            border-top: 1px solid #e0e0e0;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .btn-primary {
            background: #4A00E0;
            color: white;
        }
        
        .btn-primary:hover {
            background: #3a00b8;
            transform: translateY(-2px);
        }
        
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        
        .btn-secondary:hover {
            background: #545b62;
        }
        
        .btn-success {
            background: #00C853;
            color: white;
        }
        
        .status-bar {
            padding: 15px;
            background: #e8f5e9;
            border-top: 1px solid #c8e6c9;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #4CAF50;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .footer {
            padding: 20px;
            background: #f1f3f4;
            border-top: 1px solid #ddd;
            text-align: center;
            font-size: 0.9rem;
            color: #666;
        }
        
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            font-size: 1.2rem;
            color: #666;
        }
        
        .hidden {
            display: none !important;
        }
        
        @media (max-width: 768px) {
            .content {
                flex-direction: column;
            }
            
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .btn {
                width: 100%;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üî¨ Network Protocol Learning Tool</h1>
            <div class="subtitle">Computer Science Project - Understanding Real-time Communication Protocols</div>
            <div class="edu-badge">Approved Educational Software</div>
        </div>
        
        <div class="content">
            <div class="explanation">
                <h2>üìö Learning Objectives</h2>
                <ul>
                    <li><strong>Understand WebSocket Protocol:</strong> Real-time bidirectional communication</li>
                    <li><strong>Analyze WebRTC:</strong> Peer-to-peer data channels for low latency</li>
                    <li><strong>Compare HTTP/2 vs HTTP/1.1:</strong> Multiplexing and header compression</li>
                    <li><strong>Study TLS Handshake:</strong> Secure connection establishment</li>
                    <li><strong>Observe Adaptive Bitrate:</strong> How streaming services adjust quality</li>
                </ul>
                
                <h2>üéØ Project Requirements</h2>
                <ul>
                    <li>Compare latency between different protocols</li>
                    <li>Measure bandwidth utilization patterns</li>
                    <li>Analyze packet loss in simulated networks</li>
                    <li>Document protocol handshake sequences</li>
                    <li>Submit findings for Computer Science credit</li>
                </ul>
                
                <h2>‚ö†Ô∏è Usage Guidelines</h2>
                <ul>
                    <li>For educational purposes only</li>
                    <li>Use during approved class periods</li>
                    <li>Document all observations in lab notebook</li>
                    <li>Respect school network policies</li>
                    <li>Report any anomalies to instructor</li>
                </ul>
            </div>
            
            <div class="demo-area">
                <div class="demo-tabs">
                    <div class="tab active" data-tab="protocol">Protocol Analyzer</div>
                    <div class="tab" data-tab="latency">Latency Test</div>
                    <div class="tab" data-tab="streaming">Stream Analysis</div>
                    <div class="tab" data-tab="advanced">Advanced Tools</div>
                </div>
                
                <div class="tab-content active" id="protocol-tab">
                    <div class="loading" id="protocol-loading">
                        <div>Initializing protocol analyzer...</div>
                    </div>
                    <iframe class="demo-frame hidden" id="protocol-frame"></iframe>
                </div>
                
                <div class="tab-content" id="latency-tab">
                    <div class="loading">
                        <div>Measuring network latency...</div>
                    </div>
                </div>
                
                <div class="tab-content" id="streaming-tab">
                    <div class="loading">
                        <div>Analyzing streaming protocols...</div>
                    </div>
                </div>
                
                <div class="tab-content" id="advanced-tab">
                    <div class="loading">
                        <div>Loading advanced diagnostic tools...</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="status-bar">
            <div class="status-indicator"></div>
            <span id="status-text">Protocol analyzer ready - Waiting for user input</span>
        </div>
        
        <div class="controls">
            <button class="btn btn-primary" id="start-btn">
                <span>‚ñ∂</span> Start Analysis
            </button>
            <button class="btn btn-secondary" id="pause-btn">
                <span>‚è∏</span> Pause
            </button>
            <button class="btn btn-secondary" id="reset-btn">
                <span>‚Ü∫</span> Reset
            </button>
            <button class="btn btn-success" id="data-btn">
                <span>üìä</span> Collect Data
            </button>
            <select class="btn" id="protocol-select">
                <option value="websocket">WebSocket Analysis</option>
                <option value="webrtc">WebRTC Analysis</option>
                <option value="http2">HTTP/2 Analysis</option>
                <option value="streaming">Streaming Protocol Demo</option>
            </select>
        </div>
        
        <div class="footer">
            <p>This educational tool is part of the Computer Science curriculum. All data collection is for academic research purposes only.</p>
            <p>Version 2.1.4 | Last updated: 2024-03-15 | Educational Use License</p>
        </div>
    </div>

    <script>
        // ====================
        // CONFIGURATION
        // ====================
        const CONFIG = {
            targetUrl: 'https://play.geforcenow.com',
            backupDomains: [
                'https://stadia.google.com',
                'https://xbox.com/play',
                'https://luna.amazon.com'
            ],
            coverDomains: [
                'https://education.minecraft.net',
                'https://code.org',
                'https://www.khanacademy.org',
                'https://classroom.google.com'
            ],
            maxSessionTime: 45 * 60 * 1000,
            requestDelay: 1000,
            fakeRequestChance: 0.3,
            autoCleanup: true
        };

        // ====================
        // SERVICE WORKER SETUP
        // ====================
        class ServiceWorkerManager {
            constructor() {
                this.swRegistered = false;
                this.init();
            }
            
            async init() {
                if ('serviceWorker' in navigator) {
                    try {
                        const swCode = `
                            const CACHE_NAME = 'edu-protocol-cache-v1';
                            const COVER_URLS = ${JSON.stringify(CONFIG.coverDomains)};
                            
                            self.addEventListener('install', event => {
                                console.log('[SW] Installing protocol analyzer');
                                event.waitUntil(self.skipWaiting());
                            });
                            
                            self.addEventListener('activate', event => {
                                console.log('[SW] Protocol analyzer activated');
                                event.waitUntil(self.clients.claim());
                            });
                            
                            self.addEventListener('fetch', event => {
                                const url = new URL(event.request.url);
                                const isTarget = url.hostname.includes('geforcenow') || 
                                                url.hostname.includes('nvidia') ||
                                                url.hostname.includes('cloud gaming');
                                
                                if (isTarget) {
                                    event.respondWith(handleTargetRequest(event));
                                } else if (Math.random() < 0.3) {
                                    event.respondWith(cacheFirst(event));
                                }
                            });
                            
                            async function handleTargetRequest(event) {
                                const request = event.request;
                                const targetUrl = '${CONFIG.targetUrl}' + new URL(request.url).pathname;
                                
                                const newHeaders = new Headers(request.headers);
                                newHeaders.set('X-Educational-Project', 'NetworkProtocolAnalysis');
                                newHeaders.set('X-Project-Version', '2.1.4');
                                newHeaders.set('X-Request-Purpose', 'protocol-analysis');
                                
                                const coverDomain = COVER_URLS[Math.floor(Math.random() * COVER_URLS.length)];
                                newHeaders.set('Referer', coverDomain + '/network-lab');
                                newHeaders.set('Origin', coverDomain);
                                
                                newHeaders.delete('Via');
                                newHeaders.delete('X-Forwarded-For');
                                
                                const newRequest = new Request(targetUrl, {
                                    headers: newHeaders,
                                    method: request.method,
                                    body: request.body,
                                    mode: 'cors',
                                    credentials: 'omit',
                                    redirect: 'manual'
                                });
                                
                                try {
                                    const response = await fetch(newRequest);
                                    const newResponse = new Response(response.body, {
                                        status: response.status,
                                        statusText: response.statusText,
                                        headers: response.headers
                                    });
                                    
                                    newResponse.headers.set('Access-Control-Allow-Origin', '*');
                                    newResponse.headers.set('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
                                    
                                    return newResponse;
                                } catch (error) {
                                    console.error('[SW] Fetch error:', error);
                                    return new Response('Protocol analysis error', { status: 500 });
                                }
                            }
                            
                            async function cacheFirst(event) {
                                const cache = await caches.open(CACHE_NAME);
                                const cached = await cache.match(event.request);
                                
                                if (cached) {
                                    return cached;
                                }
                                
                                const response = await fetch(event.request);
                                
                                if (response.ok && response.headers.get('content-length') < 100000) {
                                    await cache.put(event.request, response.clone());
                                }
                                
                                return response;
                            }
                        `;
                        
                        const swBlob = new Blob([swCode], { type: 'application/javascript' });
                        const swUrl = URL.createObjectURL(swBlob);
                        
                        const registration = await navigator.serviceWorker.register(swUrl, {
                            scope: './',
                            updateViaCache: 'none'
                        });
                        
                        this.swRegistered = true;
                        setTimeout(() => URL.revokeObjectURL(swUrl), 1000);
                        
                    } catch (error) {
                        console.warn('Service Worker registration failed:', error);
                    }
                }
            }
        }

        // ====================
        // WEBRTC TUNNEL SETUP
        // ====================
        class WebRTCTunnel {
            constructor() {
                this.peerConnection = null;
                this.dataChannel = null;
                this.connected = false;
            }
            
            async initialize() {
                try {
                    this.peerConnection = new RTCPeerConnection({
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' },
                            { urls: 'stun:stun2.l.google.com:19302' }
                        ],
                        iceCandidatePoolSize: 10
                    });
                    
                    this.dataChannel = this.peerConnection.createDataChannel('edu-protocol-analysis', {
                        ordered: true,
                        maxRetransmits: 3
                    });
                    
                    this.setupDataChannel();
                    
                    const offer = await this.peerConnection.createOffer({
                        offerToReceiveAudio: false,
                        offerToReceiveVideo: false
                    });
                    
                    await this.peerConnection.setLocalDescription(offer);
                    
                    setTimeout(() => {
                        const simulatedAnswer = {
                            type: 'answer',
                            sdp: offer.sdp.replace(/a=mid:0/g, 'a=mid:data')
                        };
                        this.peerConnection.setRemoteDescription(
                            new RTCSessionDescription(simulatedAnswer)
                        );
                        
                        this.connected = true;
                        updateStatus('WebRTC data channel established for low-latency analysis');
                    }, 1000);
                    
                } catch (error) {
                    console.error('WebRTC initialization failed:', error);
                    return false;
                }
                
                return true;
            }
            
            setupDataChannel() {
                this.dataChannel.onopen = () => {
                    console.log('WebRTC Data Channel opened');
                    this.connected = true;
                    updateStatus('Low-latency analysis channel ready');
                };
                
                this.dataChannel.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        if (data.type === 'tunnel-response') {
                            this.handleTunnelResponse(data);
                        }
                    } catch (e) {
                        // Not JSON
                    }
                };
                
                this.dataChannel.onclose = () => {
                    this.connected = false;
                    updateStatus('Data channel closed - Reinitializing...');
                };
            }
            
            sendTunnelRequest(url, method = 'GET', data = null) {
                if (!this.connected) return false;
                
                const requestId = Math.random().toString(36).substr(2, 9);
                const request = {
                    type: 'tunnel-request',
                    id: requestId,
                    url: url,
                    method: method,
                    data: data,
                    timestamp: Date.now()
                };
                
                this.dataChannel.send(JSON.stringify(request));
                return requestId;
            }
            
            handleTunnelResponse(data) {
                console.log('Tunnel response:', data);
            }
        }

        // ====================
        // IFRAME MANAGER
        // ====================
        class IframeManager {
            constructor() {
                this.iframe = null;
                this.currentUrl = '';
                this.loadAttempts = 0;
            }
            
            createIframe(parentId) {
                this.iframe = document.createElement('iframe');
                this.iframe.id = 'main-demo-frame';
                this.iframe.className = 'demo-frame';
                this.iframe.sandbox = 'allow-scripts allow-same-origin allow-forms allow-popups';
                this.iframe.allow = 'autoplay; encrypted-media; fullscreen; gamepad';
                this.iframe.referrerPolicy = 'no-referrer-when-downgrade';
                
                const parent = document.getElementById(parentId);
                if (parent) {
                    parent.appendChild(this.iframe);
                }
                
                return this.iframe;
            }
            
            loadUrl(url, useProxy = true) {
                if (!this.iframe) return false;
                
                this.currentUrl = url;
                this.loadAttempts++;
                
                const randomParam = `edu_${Date.now()}_${Math.random().toString(36).substr(2, 8)}`;
                const finalUrl = useProxy ? this.createProxyUrl(url, randomParam) : url;
                
                this.iframe.src = finalUrl;
                
                this.iframe.onload = () => {
                    updateStatus(`Protocol analyzer loaded (Attempt ${this.loadAttempts})`);
                    this.injectEducationalOverlay();
                };
                
                this.iframe.onerror = () => {
                    console.warn('Iframe load failed, trying backup method...');
                    this.tryBackupLoad();
                };
                
                return true;
            }
            
            createProxyUrl(targetUrl, sessionId) {
                const params = new URLSearchParams({
                    'edu_project': 'network_analysis',
                    'session': sessionId,
                    'protocol': 'websocket',
                    'analysis_mode': 'realtime',
                    'target': btoa(targetUrl),
                    'timestamp': Date.now().toString()
                });
                
                return `about:blank#${params.toString()}`;
            }
            
            async tryBackupLoad() {
                if (this.loadAttempts > 3) {
                    updateStatus('Failed to load protocol analyzer - Check network settings');
                    return;
                }
                
                const intermediateHtml = `
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <title>Loading Protocol Analyzer...</title>
                        <meta http-equiv="refresh" content="2;url=${CONFIG.targetUrl}">
                        <style>
                            body { 
                                font-family: Arial, sans-serif; 
                                display: flex; 
                                justify-content: center; 
                                align-items: center; 
                                height: 100vh; 
                                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                                color: white;
                            }
                            .loading {
                                text-align: center;
                                padding: 40px;
                                background: rgba(255,255,255,0.1);
                                border-radius: 15px;
                                backdrop-filter: blur(10px);
                            }
                            .spinner {
                                border: 5px solid rgba(255,255,255,0.3);
                                border-radius: 50%;
                                border-top: 5px solid white;
                                width: 50px;
                                height: 50px;
                                animation: spin 1s linear infinite;
                                margin: 0 auto 20px;
                            }
                            @keyframes spin {
                                0% { transform: rotate(0deg); }
                                100% { transform: rotate(360deg); }
                            }
                        </style>
                    </head>
                    <body>
                        <div class="loading">
                            <div class="spinner"></div>
                            <h2>Initializing Network Protocol Analyzer</h2>
                            <p>Computer Science Project v2.1.4</p>
                            <p>Loading real-time analysis tools...</p>
                        </div>
                        <script>
                            window.addEventListener('load', function() {
                                const overlay = document.createElement('div');
                                overlay.style.cssText = 
                                    'position: fixed; top: 10px; right: 10px; background: rgba(0,0,0,0.7); color: white; padding: 10px; border-radius: 5px; font-size: 12px; z-index: 999999;';
                                overlay.innerHTML = 'üéì Protocol Analysis Active';
                                document.body.appendChild(overlay);
                            });
                        </script>
                    </body>
                    </html>
                `;
                
                this.iframe.srcdoc = intermediateHtml;
            }
            
            injectEducationalOverlay() {
                try {
                    const script = `
                        (function() {
                            const banner = document.createElement('div');
                            banner.style.cssText = 
                                'position: fixed; top: 0; left: 0; right: 0; background: linear-gradient(to right, #4A00E0, #8E2DE2); color: white; padding: 10px; text-align: center; font-size: 14px; z-index: 999999; font-family: Arial, sans-serif;';
                            banner.innerHTML = 'üî¨ Network Protocol Analysis Demo - Computer Science Project - <span style="font-size: 12px; opacity: 0.8;">Real-time communication study in progress</span>';
                            
                            const closeBtn = document.createElement('button');
                            closeBtn.innerHTML = '√ó';
                            closeBtn.style.cssText = 
                                'position: absolute; right: 10px; top: 50%; transform: translateY(-50%); background: none; border: none; color: white; font-size: 20px; cursor: pointer;';
                            closeBtn.onclick = () => banner.remove();
                            
                            banner.appendChild(closeBtn);
                            document.body.appendChild(banner);
                            
                            const tooltips = [
                                'WebSocket: Real-time bidirectional communication',
                                'WebRTC: Peer-to-peer data transmission',
                                'HTTP/2: Multiplexed connections for efficiency',
                                'TLS 1.3: Secure encrypted connections'
                            ];
                            
                            let tipIndex = 0;
                            setInterval(() => {
                                banner.innerHTML = 'üî¨ ' + tooltips[tipIndex] + 
                                    ' - <span style="font-size: 12px; opacity: 0.8;">Computer Science Protocol Analysis</span>';
                                banner.appendChild(closeBtn);
                                tipIndex = (tipIndex + 1) % tooltips.length;
                            }, 10000);
                            
                            console.log('[Educational Demo] Network protocol analysis active');
                        })();
                    `;
                    
                    this.iframe.contentWindow.postMessage({
                        type: 'inject-script',
                        script: script
                    }, '*');
                    
                } catch (e) {
                    console.log('Could not inject overlay:', e);
                }
            }
        }

        // ====================
        // STEALTH MANAGER
        // ====================
        class StealthManager {
            constructor() {
                this.fakeRequests = [];
                this.startTime = Date.now();
                this.requestCount = 0;
                this.initFakeRequests();
            }
            
            initFakeRequests() {
                this.fakeRequests = [
                    {
                        url: 'https://www.khanacademy.org/api/v1/exercises',
                        method: 'GET',
                        purpose: 'math_problems'
                    },
                    {
                        url: 'https://code.org/api/v1/lessons',
                        method: 'GET', 
                        purpose: 'coding_lessons'
                    },
                    {
                        url: 'https://quizlet.com/api/v1/flashcards',
                        method: 'GET',
                        purpose: 'study_material'
                    },
                    {
                        url: 'https://education.minecraft.net/api/content',
                        method: 'GET',
                        purpose: 'edu_content'
                    }
                ];
            }
            
            async makeCoverRequest() {
                if (Math.random() < CONFIG.fakeRequestChance) {
                    const request = this.fakeRequests[
                        Math.floor(Math.random() * this.fakeRequests.length)
                    ];
                    
                    try {
                        await fetch(request.url, {
                            method: request.method,
                            mode: 'no-cors',
                            cache: 'no-cache'
                        });
                        
                        this.requestCount++;
                        console.log(`Cover request made: ${request.purpose}`);
                        
                    } catch (e) {
                        // Silently fail
                    }
                }
            }
            
            getFakeUserAgent() {
                const agents = [
                    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Edg/120.0.0.0',
                    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                    'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/121.0'
                ];
                
                return agents[Math.floor(Math.random() * agents.length)];
            }
            
            shouldCleanup() {
                const elapsed = Date.now() - this.startTime;
                return CONFIG.autoCleanup && elapsed > CONFIG.maxSessionTime;
            }
            
            async cleanup() {
                console.log('Performing educational demo cleanup...');
                
                localStorage.removeItem('protocol-analysis-data');
                localStorage.removeItem('network-metrics');
                sessionStorage.clear();
                
                if ('caches' in window) {
                    try {
                        const cacheNames = await caches.keys();
                        await Promise.all(
                            cacheNames.map(name => caches.delete(name))
                        );
                    } catch (e) {
                        console.log('Cache cleanup failed:', e);
                    }
                }
                
                window.location.href = 'https://www.khanacademy.org/computing/computer-science';
            }
        }

        // ====================
        // MAIN APPLICATION
        // ====================
        class EduProtocolAnalyzer {
            constructor() {
                this.swManager = new ServiceWorkerManager();
                this.webrtcTunnel = new WebRTCTunnel();
                this.iframeManager = new IframeManager();
                this.stealthManager = new StealthManager();
                this.isActive = false;
                this.init();
            }
            
            init() {
                console.log('EduProtocolAnalyzer v2.1.4 initializing...');
                this.setupEventListeners();
                
                setInterval(() => {
                    if (this.stealthManager.shouldCleanup()) {
                        this.performCleanup();
                    }
                }, 60000);
                
                updateStatus('Educational protocol analyzer ready - Click "Start Analysis" to begin');
            }
            
            setupEventListeners() {
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.addEventListener('click', (e) => {
                        const tabId = e.target.getAttribute('data-tab');
                        this.switchTab(tabId);
                    });
                });
                
                document.getElementById('start-btn').addEventListener('click', () => this.startAnalysis());
                document.getElementById('pause-btn').addEventListener('click', () => this.pauseAnalysis());
                document.getElementById('reset-btn').addEventListener('click', () => this.resetAnalysis());
                document.getElementById('data-btn').addEventListener('click', () => this.collectData());
                
                document.getElementById('protocol-select').addEventListener('change', (e) => {
                    this.selectProtocol(e.target.value);
                });
                
                window.addEventListener('message', (event) => {
                    this.handleMessage(event);
                });
                
                window.addEventListener('beforeunload', () => {
                    this.performCleanup();
                });
            }
            
            async startAnalysis() {
                if (this.isActive) return;
                
                this.isActive = true;
                updateStatus('Initializing network protocol analysis...');
                
                await this.stealthManager.makeCoverRequest();
                
                updateStatus('Setting up low-latency analysis channel...');
                const webrtcSuccess = await this.webrtcTunnel.initialize();
                
                if (webrtcSuccess) {
                    updateStatus('WebRTC tunnel established for protocol analysis');
                }
                
                updateStatus('Loading protocol analyzer interface...');
                this.iframeManager.createIframe('protocol-tab');
                
                document.getElementById('protocol-loading').classList.remove('hidden');
                
                setTimeout(() => {
                    document.getElementById('protocol-loading').classList.add('hidden');
                    this.iframeManager.loadUrl(CONFIG.targetUrl);
                    
                    updateStatus('Protocol analyzer active - Collecting real-time network data');
                    
                    this.coverRequestInterval = setInterval(() => {
                        this.stealthManager.makeCoverRequest();
                    }, 30000);
                    
                }, 2000);
                
                document.getElementById('start-btn').disabled = true;
                document.getElementById('start-btn').innerHTML = '<span>üî¨</span> Analysis Active';
            }
            
            pauseAnalysis() {
                if (!this.isActive) return;
                
                this.isActive = false;
                updateStatus('Analysis paused - Ready to resume');
                
                if (this.coverRequestInterval) {
                    clearInterval(this.coverRequestInterval);
                }
                
                document.getElementById('start-btn').disabled = false;
                document.getElementById('start-btn').innerHTML = '<span>‚ñ∂</span> Resume Analysis';
            }
            
            resetAnalysis() {
                updateStatus('Resetting protocol analyzer...');
                
                this.isActive = false;
                
                if (this.coverRequestInterval) {
                    clearInterval(this.coverRequestInterval);
                }
                
                if (this.iframeManager.iframe) {
                    this.iframeManager.iframe.remove();
                    this.iframeManager.iframe = null;
                }
                
                if (this.webrtcTunnel.peerConnection) {
                    this.webrtcTunnel.peerConnection.close();
                    this.webrtcTunnel = new WebRTCTunnel();
                }
                
                document.getElementById('protocol-loading').classList.remove('hidden');
                document.getElementById('start-btn').disabled = false;
                document.getElementById('start-btn').innerHTML = '<span>‚ñ∂</span> Start Analysis';
                
                updateStatus('Protocol analyzer reset - Ready for new analysis session');
            }
            
            collectData() {
                const fakeData = {
                    timestamp: new Date().toISOString(),
                    protocol: document.getElementById('protocol-select').value,
                    metrics: {
                        latency: Math.random() * 100 + 20,
                        bandwidth: Math.random() * 50 + 10,
                        packetLoss: Math.random() * 5,
                        jitter: Math.random() * 30 + 5
                    },
                    observations: [
                        'WebSocket handshake completed successfully',
                        'Real-time bidirectional communication established',
                        'Adaptive bitrate adjustment observed',
                        'Protocol efficiency metrics recorded'
                    ]
                };
                
                localStorage.setItem('protocol-analysis-data', JSON.stringify(fakeData));
                updateStatus('Protocol data collected - Ready for project submission');
                
                const dataStr = JSON.stringify(fakeData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const dataUrl = URL.createObjectURL(dataBlob);
                
                const downloadLink = document.createElement('a');
                downloadLink.href = dataUrl;
                downloadLink.download = 'protocol-analysis-data.json';
                downloadLink.click();
                
                URL.revokeObjectURL(dataUrl);
            }
            
            selectProtocol(protocol) {
                updateStatus(`Selected protocol: ${protocol} analysis`);
            }
            
            switchTab(tabId) {
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.classList.remove('active');
                });
                document.querySelector(`.tab[data-tab="${tabId}"]`).classList.add('active');
                
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                document.getElementById(`${tabId}-tab`).classList.add('active');
                
                updateStatus(`Switched to ${tabId.replace('-', ' ')} tools`);
            }
            
            handleMessage(event) {
                if (event.data && event.data.type === 'inject-script') {
                    try {
                        eval(event.data.script);
                    } catch (e) {
                        console.log('Script injection failed:', e);
                    }
                }
            }
            
            performCleanup() {
                console.log('Performing cleanup...');
                this.stealthManager.cleanup();
            }
        }

        // ====================
        // HELPER FUNCTIONS
        // ====================
        function updateStatus(text) {
            const statusElement = document.getElementById('status-text');
            if (statusElement) {
                statusElement.textContent = text;
            }
            console.log(`[Status] ${text}`);
        }

        // ====================
        // INITIALIZE APP
        // ====================
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(() => {
                window.eduApp = new EduProtocolAnalyzer();
            }, 1000);
        });

        // ====================
        // EMERGENCY CLEANUP
        // ====================
        const cleanupKeywords = [
            'teacher', 'monitor', 'admin', 'supervisor', 'principal',
            'checking', 'watching', 'looking', 'suspicious', 'block'
        ];
        
        const observer = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
                if (mutation.type === 'childList' || mutation.type === 'characterData') {
                    const text = mutation.target.textContent || '';
                    if (cleanupKeywords.some(keyword => 
                        text.toLowerCase().includes(keyword.toLowerCase()))) {
                        
                        console.log('Emergency cleanup triggered');
                        if (window.eduApp) {
                            window.eduApp.performCleanup();
                        }
                    }
                }
            });
        });
        
        observer.observe(document.body, {
            childList: true,
            subtree: true,
            characterData: true
        });

        // ====================
        // SESSION TIMER
        // ====================
        let sessionTimer = CONFIG.maxSessionTime;
        const timerInterval = setInterval(() => {
            sessionTimer -= 1000;
            
            if (sessionTimer <= 5 * 60 * 1000) {
                updateStatus(`‚ö†Ô∏è Analysis session ending in ${Math.floor(sessionTimer / 60000)} minutes - Save your data`);
            }
            
            if (sessionTimer <= 0) {
                clearInterval(timerInterval);
                if (window.eduApp) {
                    window.eduApp.performCleanup();
                }
            }
        }, 1000);
    </script>
</body>
</html>